# ddc.vim {{{
[[plugins]]
repo = 'Shougo/ddc.vim'
depends = ['denops.vim', 'pum.vim']
on_event = ['InsertEnter', 'CmdlineEnter', 'CursorHold', 'CursorHoldI']
hook_source = '''
if has('nvim')
  call ddc#custom#patch_global('sources',
      \ ['around', 'buffer', 'file', 'rg', 'vsnip', 'nvim-lsp']
      \ )
else
  call ddc#custom#patch_global('sources',
      \ ['around', 'buffer', 'file', 'rg']
      \ )
endif
call ddc#custom#patch_global('cmdlineSources',
    \ ['cmdline', 'input', 'file', 'around']
    \ )
" sourceOptions {{{
call ddc#custom#patch_global('sourceOptions', {
    \ '_': {
    \   'ignoreCase': v:true,
    \   'matchers': ['matcher_fuzzy'],
    \   'sorters': ['sorter_fuzzy'],
    \   'converters': ['converter_fuzzy']
    \ },
    \ 'around': {
    \   'mark': 'around',
    \   'dup': v:false
    \ },
    \ 'buffer': {
    \   'mark': 'buffer'
    \ },
    \ 'file': {
    \   'mark': 'file',
    \   'isVolatile': v:true,
    \   'minAutoCompleteLength': 1000,
    \   'forceCompletionPattern': '\S/\S*'
    \ },
    \ 'rg': {
    \   'mark': 'ripgrep',
    \   'minAutoCompleteLength': 5,
    \   'enabledIf': "finddir('.git', ';') != ''",
    \ },
    \ 'nvim-lsp': {
    \   'mark': 'nvim-lsp',
    \   'forceCompletionPattern': '\.\w*|:\w*|->\w*',
    \   'dup': v:true
    \ },
    \ 'vsnip': {
    \   'mark': 'vsnip',
    \   'dup': v:true
    \ },
    \ 'mocword': {
    \   'mark': 'mocword',
    \   'minAutoCompleteLength': 3,
    \   'isVolatile': v:true,
    \ },
    \ 'cmdline': {
    \   'mark': 'cmdline',
    \   'forceCompletionPattern': '\S/\S*',
    \   'dup': v:true,
    \ },
    \ 'cmdline-history': {
    \   'mark': 'history',
    \ },
    \ 'input': {
    \   'mark': 'input',
    \   'isVolatile': v:true,
    \ },
    \ })
call ddc#custom#patch_global('sourceOptions', {
    \ 'skkeleton': {
    \   'mark': 'skk',
    \   'matchers': ['skkeleton'],
    \   'sorters': [],
    \   'minAutoCompleteLength': 0,
    \   'isVolatile': v:true,
    \ }})
" }}}
call ddc#custom#set_context_filetype('go', { ->
    \ ddc#syntax#in('TSComment') ? {
    \   'sources': ['around', 'mocword'],
    \ } : {} })
call ddc#custom#set_context_filetype('c', { ->
    \ ddc#syntax#in('Comment') ? {
    \   'sources': ['around', 'mocword'],
    \ } : {} })
call ddc#custom#patch_global('autoCompleteEvents', [
    \ 'InsertEnter', 'TextChangedI', 'TextChangedP',
    \ 'CmdlineEnter', 'CmdlineChanged',
    \ ])
" Insert mode completion {{{
inoremap <silent><expr> <TAB>
      \ pum#visible() ? '<Cmd>call pum#map#insert_relative(+1)<CR>' :
      \ (col('.') <= 1 <Bar><Bar> getline('.')[col('.') - 2] =~# '\s') ?
      \ '<TAB>' : ddc#manual_complete()
inoremap <S-Tab> <Cmd>call pum#map#insert_relative(-1)<CR>
inoremap <C-n>   <Cmd>call pum#map#insert_relative(+1)<CR>
inoremap <C-p>   <Cmd>call pum#map#insert_relative(-1)<CR>
inoremap <C-o>   <Cmd>call pum#map#confirm()<CR>
inoremap <C-e>   <Cmd>call pum#map#cancel()<CR>
inoremap <silent><expr> <C-l>   ddc#map#extend()
inoremap <silent><expr> <C-x><C-f> ddc#manual_complete('path')
" }}}

" Command line mode completion {{{
nnoremap : <Cmd>call CommandlinePre()<CR>:

function! CommandlinePre() abort
  " Note: It disables default command line completion!
  cnoremap <expr> <Tab>
  \ pum#visible() ? '<Cmd>call pum#map#insert_relative(+1)<CR>' :
  \ exists('b:ddc_cmdline_completion') ?
  \ ddc#manual_complete() : nr2char(&wildcharm)
  cnoremap <S-Tab> <Cmd>call pum#map#insert_relative(-1)<CR>
  cnoremap <C-n>   <Cmd>call pum#map#insert_relative(+1)<CR>
  cnoremap <C-p>   <Cmd>call pum#map#insert_relative(-1)<CR>
  cnoremap <C-o>   <Cmd>call pum#map#confirm()<CR>
  cnoremap <C-e>   <Cmd>call pum#map#cancel()<CR>

  " Overwrite sources
  if !exists('b:prev_buffer_config')
    let b:prev_buffer_config = ddc#custom#get_buffer()
  endif
  call ddc#custom#patch_buffer('sources',
          \ ['cmdline', 'cmdline-history', 'around'])

  autocmd User DDCCmdlineLeave ++once call CommandlinePost()
  " autocmd InsertEnter <buffer> ++once call CommandlinePost()

  " Enable command line completion
  call ddc#enable_cmdline_completion()
endfunction

function! CommandlinePost() abort
  cunmap <Tab>
  cunmap <S-Tab>
  cunmap <C-n>
  cunmap <C-p>
  cunmap <C-o>
  cunmap <C-e>

  " Restore sources
  if exists('b:prev_buffer_config')
    call ddc#custom#set_buffer(b:prev_buffer_config)
    unlet b:prev_buffer_config
  else
    call ddc#custom#set_buffer({})
  endif
endfunction
" }}}

call ddc#enable()
'''
# }}}
# ddc-ui-pum {{{
[[plugins]]
repo = 'Shougo/ddc-ui-pum'
on_source = 'ddc.vim'
hook_source = '''
call ddc#custom#patch_global('ui', 'pum')
'''
# }}}
# pum.vim {{{
[[plugins]]
repo = 'Shougo/pum.vim'
on_source = 'ddc.vim'
hook_source = '''
call pum#set_option('border', 'single')
call pum#set_option('use_complete', v:true)
call pum#set_option('scrollbar_char','')
'''
# }}}
# ddc sources {{{
[[plugins]]
repo = 'Shougo/ddc-around'
on_source = 'ddc.vim'

[[plugins]]
repo = 'Shougo/ddc-nvim-lsp'
on_source = 'ddc.vim'

[[plugins]]
repo = 'LumaKernel/ddc-file'
on_source = 'ddc.vim'

[[plugins]]
repo = 'Shougo/ddc-rg'
on_source = 'ddc.vim'

[[plugins]]
repo = 'matsui54/ddc-buffer'
on_source = 'ddc.vim'

[[plugins]]
repo = 'Shougo/ddc-mocword'
on_source = 'ddc.vim'

[[plugins]]
repo = 'hrsh7th/vim-vsnip'
depends = ['vim-vsnip-integ', 'friendly-snippets']
on_source = 'ddc.vim'
hook_add = '''
" Expand
imap <expr> <C-l>   vsnip#expandable()  ? '<Plug>(vsnip-expand)'         : '<C-l>'
smap <expr> <C-l>   vsnip#expandable()  ? '<Plug>(vsnip-expand)'         : '<C-l>'

" Jump forward or backward
imap <expr> <Tab>   vsnip#jumpable(1)   ? '<Plug>(vsnip-jump-next)'      : '<Tab>'
smap <expr> <Tab>   vsnip#jumpable(1)   ? '<Plug>(vsnip-jump-next)'      : '<Tab>'
imap <expr> <S-Tab> vsnip#jumpable(-1)  ? '<Plug>(vsnip-jump-prev)'      : '<S-Tab>'
smap <expr> <S-Tab> vsnip#jumpable(-1)  ? '<Plug>(vsnip-jump-prev)'      : '<S-Tab>'
let g:vsnip_snippet_dir = expand('~/.config/nvim/vsnip')
'''
[[plugins]]
repo = 'hrsh7th/vim-vsnip-integ'

[[plugins]]
repo = 'rafamadriz/friendly-snippets'

[[plugins]]
repo = 'Shougo/ddc-cmdline'
on_source = 'ddc.vim'

[[plugins]]
repo = 'Shougo/ddc-cmdline-history'
on_source = 'ddc.vim'

[[plugins]]
repo = 'Shougo/ddc-input'
on_source = 'ddc.vim'
# }}}
# ddc filters {{{
[[plugins]]
repo = 'tani/ddc-fuzzy'
on_source = 'ddc.vim'
# }}}
# skkeleton {{{
[[plugins]]
repo = 'vim-skk/skkeleton'
on_map = { ic = '<Plug>(skkeleton-toggle)' }
depends = ['ddc.vim']
hook_add = '''
nmap <C-j> i<Plug>(skkeleton-toggle)
imap <C-j> <Plug>(skkeleton-toggle)
cmap <C-j> <Plug>(skkeleton-toggle)
'''
hook_post_source = '''
" let g:skkeleton#debug = v:true
call skkeleton#config({
      \ 'eggLikeNewline': v:true,
      \ 'registerConvertResult': v:true,
      \ })
call skkeleton#register_kanatable('rom', {
      \ 'jj': 'escape',
      \ '~': ['ã€œ', ''],
      \ "z\<Space>": ["\u3000", ''],
      \ })

" skkeleton_pre
autocmd User skkeleton-enable-pre call s:skkeleton_pre()
function! s:skkeleton_pre() abort
  " Overwrite sources
  let s:prev_buffer_config = ddc#custom#get_buffer()
  call ddc#custom#patch_buffer('sources', ['skkeleton'])
endfunction

" skkeleton_post
autocmd User skkeleton-disable-pre call s:skkeleton_post()
function! s:skkeleton_post() abort
  " Restore sources
  call ddc#custom#set_buffer(s:prev_buffer_config)
endfunction

" ddc config
call ddc#custom#patch_global('sourceOptions', {
    \ 'skkeleton': {
    \   'mark': 'skk',
    \   'matchers': ['skkeleton'],
    \   'sorters': [],
    \   'minAutoCompleteLength': 2,
    \ }})
'''

#[[plugins]]
#repo = 'shg-eo/skkeleton-azik'
#on_source = 'skkeleton'

[[plugins]]
repo = 'Matts966/skk-vconv.vim'
on_source = ['skkeleton']
# }}}
# compdoc {{{
[[plugins]]
repo = 'matsui54/denops-popup-preview.vim'
on_source = 'ddc.vim'
hook_source = '''
call popup_preview#enable()
let g:popup_preview_config = {
  \ 'delay': 500,
  \ }
'''
[[plugins]]
repo = 'matsui54/denops-signature_help'
on_source = 'ddc.vim'
hook_source = '''
call signature_help#enable()
'''
# }}}
# vim: fdm=marker
